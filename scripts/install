#!/usr/bin/env sh
#
# This script is based on https://github.com/ohmyzsh/ohmyzsh.
#
# This script should be run via curl:
#   sh -c "$(curl -fsSL https://raw.githubusercontent.com/kw-yud/doty/main/scripts/install)"
# or via wget:
#   sh -c "$(wget -qO- https://raw.githubusercontent.com/kw-yud/doty/main/scripts/install)"
# or via fetch:
#   sh -c "$(fetch -o - https://raw.githubusercontent.com/kw-yud/doty/main/scripts/install)"
#
# As an alternative, you can first download the install script and run it afterwards:
#   wget https://raw.githubusercontent.com/kw-yud/doty/main/scripts/install
#   sh install
#
# You can tweak the install behavior by setting variables when running the script. For
# example, to change the path to the Doty repository:
#   DOTY=~/.doty sh install
#
# Respects the following environment variables:
#   ZDOTDIR - path to Zsh dotfiles directory (default: unset). See [1][2]
#             [1] https://zsh.sourceforge.io/Doc/Release/Parameters.html#index-ZDOTDIR
#             [2] https://zsh.sourceforge.io/Doc/Release/Files.html#index-ZDOTDIR_002c-use-of
#   DOTY    - path to the Doty repository folder (default: $HOME/.doty)
#   REMOTE  - full remote URL of the git repo to install (default: GitHub via HTTPS https://github.com/kw-yud/doty.git)
#   BRANCH  - branch to check out immediately after install (default: main)
#
# Other options:
#   CHANGE_SHELL  - 'no' means the installer will not change the default shell (default: yes)
#   RUN_ZSH       - 'no' means the installer will not run zsh after the install (default: yes)
#   KEEP_ZSHRC    - 'yes' means the installer will not replace an existing .zshrc (default: no)
#   KEEP_TMUXCONF - 'yes' means the installer will not replace an existing .tmux.conf (default: no)
#   KEEP_NVIMCONF - 'yes' means the installer will not replace an existing nvim/init.lua (default: no)
#
# You can also pass some arguments to the install script to set some these options:
#   --no-change-shell: has the same behavior as setting CHANGE_SHELL to 'no'
#   --unattended:      sets both CHANGE_SHELL and RUN_ZSH to 'no'
#   --keep-zshrc:      sets KEEP_ZSHRC to 'yes'
#   --keep-tmux:       sets KEEP_TMUXCONF to 'yes'
#   --keep-nvim:       sets KEEP_NVIMCONF to 'yes'
# For example:
#   sh install --unattended
# or:
#   sh -c "$(curl -fsSL https://raw.githubusercontent.com/kw-yud/doty/main/scripts/install)" "" --unattended

set -e

# Make sure important variables exist if not already defined.
#
# $USER is defined by login(1) which is not always executed (e.g. containers)
# POSIX: https://pubs.opengroup.org/onlinepubs/009695299/utilities/id.html
USER=${USER:-$(id -u -n)}

# $HOME is defined at the time of login, but it could be unset. If it is unset,
# a tilde by itself (~) will not be expanded to the current user's home directory.
# POSIX: https://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap08.html#tag_08_03
HOME="${HOME:-$(getent passwd $USER 2>/dev/null | cut -d: -f6)}"
# macOS does not have getent, but this works even if $HOME is unset.
HOME="${HOME:-$(eval echo ~$USER)}"

# Track if $DOTY was provided.
custom_doty=${DOTY:+yes}

# Use $zdot to keep track of where the directory is for zsh dotfiles.
# To check if $ZDOTDIR was provided, explicitly check for $ZDOTDIR.
zdot="${ZDOTDIR:-$HOME}"

# Default value for $DOTY:
# a) if $ZDOTDIR is supplied and not $HOME: $ZDOTDIR/.doty
# b) otherwise, $HOME/.doty
[ "$ZDOTDIR" = "$HOME" ] || DOTY="${DOTY:-${ZDOTDIR:+$ZDOTDIR/.doty}}"
DOTY="${DOTY:-$HOME/.doty}"

# Default settings.
DOTY_REPOSITORY_REMOTE=${DOTY_REPOSITORY_REMOTE:-https://github.com/kw-yud/doty.git}
DOTY_REPOSITORY_BRANCH=${DOTY_REPOSITORY_BRANCH:-main}

# Other options.
CHANGE_SHELL=${CHANGE_SHELL:-yes}
RUN_ZSH=${RUN_ZSH:-yes}
KEEP_ZSHRC=${KEEP_ZSHRC:-no}
KEEP_TMUXCONF=${KEEP_TMUXCONF:-no}
KEEP_NVIMCONF=${KEEP_NVIMCONF:-no}

backup_dir="${DOTY}/.backups/$(date +%Y-%m-%d_%H-%M-%S)"

# The [ -t 1 ] check only works when the function is not called from
# a subshell (like in `$(...)` or `(...)`, so this hack redefines the
# function at the top level to always return false when stdout is not
# a tty.
if [ -t 1 ]; then
    is_tty() {
        true
    }
else
    is_tty() {
        false
    }
fi

command_exists() {
    command -v "$@" >/dev/null 2>&1
}

# Test whether a Homebrew formula is already installed
# $1 - formula name (may include options)
function formula_is_exists() {
    if $(brew list $1 >/dev/null); then
        info "$1 already installed."
        return 0
    fi

    warning "Missing formula: $1"
    return 1
}

prompt() {
    printf '%s%s%s' $FMT_YELLOW $FMT_RESET "$1" >&2
    read -p " ${FMT_BLACK}[y/N]${FMT_RESET} ${FMT_BOLD}" a
    printf "${FMT_RESET}" >&2
    if [[ $a == "y" || $a == "Y" ]]; then
        return 1
    fi
    return 0
}

user_can_sudo() {
    # Check if sudo is installed
    command_exists sudo || return 1
    # Termux can't run sudo, so we can detect it and exit the function early.
    case "$PREFIX" in
    *com.termux*) return 1 ;;
    esac
    # The following command has 3 parts:
    #
    # 1. Run `sudo` with `-v`. Does the following:
    #    • with privilege: asks for a password immediately.
    #    • without privilege: exits with error code 1 and prints the message:
    #      Sorry, user <username> may not run sudo on <hostname>
    #
    # 2. Pass `-n` to `sudo` to tell it to not ask for a password. If the
    #    password is not required, the command will finish with exit code 0.
    #    If one is required, sudo will exit with error code 1 and print the
    #    message:
    #    sudo: a password is required
    #
    # 3. Check for the words "may not run sudo" in the output to really tell
    #    whether the user has privileges or not. For that we have to make sure
    #    to run `sudo` in the default locale (with `LANG=`) so that the message
    #    stays consistent regardless of the user's locale.
    #
    ! LANG= sudo -n -v 2>&1 | grep -q "may not run sudo"
}

# Adapted from code and information by Anton Kochkov (@XVilka)
# Source: https://gist.github.com/XVilka/8346728
supports_truecolor() {
    case "$COLORTERM" in
    truecolor | 24bit) return 0 ;;
    esac

    case "$TERM" in
    iterm | \
        tmux-truecolor | \
        linux-truecolor | \
        xterm-truecolor | \
        screen-truecolor) return 0 ;;
    esac

    return 1
}

# This function uses the logic from supports-hyperlinks[1][2], which is
# made by Kat Marchán (@zkat) and licensed under the Apache License 2.0.
# [1] https://github.com/zkat/supports-hyperlinks
# [2] https://crates.io/crates/supports-hyperlinks
#
# Copyright (c) 2021 Kat Marchán
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
supports_hyperlinks() {
    # $FORCE_HYPERLINK must be set and be non-zero (this acts as a logic bypass)
    if [ -n "$FORCE_HYPERLINK" ]; then
        [ "$FORCE_HYPERLINK" != 0 ]
        return $?
    fi

    # If stdout is not a tty, it doesn't support hyperlinks
    is_tty || return 1

    # DomTerm terminal emulator (domterm.org)
    if [ -n "$DOMTERM" ]; then
        return 0
    fi

    # VTE-based terminals above v0.50 (Gnome Terminal, Guake, ROXTerm, etc)
    if [ -n "$VTE_VERSION" ]; then
        [ $VTE_VERSION -ge 5000 ]
        return $?
    fi

    # If $TERM_PROGRAM is set, these terminals support hyperlinks
    case "$TERM_PROGRAM" in
    Hyper | iTerm.app | terminology | WezTerm) return 0 ;;
    esac

    # kitty supports hyperlinks
    if [ "$TERM" = xterm-kitty ]; then
        return 0
    fi

    # Windows Terminal also supports hyperlinks
    if [ -n "$WT_SESSION" ]; then
        return 0
    fi

    # Konsole supports hyperlinks, but it's an opt-in setting that can't be detected
    # https://github.com/ohmyzsh/ohmyzsh/issues/10964
    # if [ -n "$KONSOLE_VERSION" ]; then
    #   return 0
    # fi

    return 1
}

underline() {
    is_tty && printf '\033[4m%s\033[24m' "$*" >&2 || printf '%s' "$*" >&2
}

link() {
    # $1: text, $2: url, $3: fallback mode
    if supports_hyperlinks; then
        printf '\033]8;;%s\033\\%s\033]8;;\033\\' "$2" "$1" >&2
        return
    fi

    case "$3" in
    --text) printf '%s\n' "$1" >&2 ;;
    --url | *) underline "$2" ;;
    esac
}

# shellcheck disable=SC2016 # backtick in single-quote
fmt_code() {
    is_tty && printf '\033[2m%s\033[22m' "$*" >&2 || printf '`%s`' "$*" >&2
}

codeblock() {
    codeblock $*
    printf '\n' >&2
}

success() {
    printf '%s%s%s\n' "${FMT_BOLD}${FMT_GREEN}" "$*" "$FMT_RESET" >&2
}

info() {
    printf '%s%s%s\n' "${FMT_BOLD}${FMT_BLUE}" "$*" "$FMT_RESET" >&2
}

warning() {
    printf '%s%s%s\n' "${FMT_BOLD}${FMT_YELLOW}" "$*" "$FMT_RESET" >&2
}

error() {
    printf '%s%s%s\n' "${FMT_BOLD}${FMT_RED}" "$*" "$FMT_RESET" >&2
}

setup_color() {
    # Only use colors if connected to a terminal
    if ! is_tty; then
        FMT_RAINBOW=""
        FMT_RED=""
        FMT_GREEN=""
        FMT_YELLOW=""
        FMT_BLUE=""
        FMT_BOLD=""
        FMT_RESET=""
        return
    fi

    if supports_truecolor; then
        FMT_RAINBOW="
      $(printf '\033[38;2;255;0;0m')
      $(printf '\033[38;2;255;97;0m')
      $(printf '\033[38;2;247;255;0m')
      $(printf '\033[38;2;0;255;30m')
      $(printf '\033[38;2;77;0;255m')
      $(printf '\033[38;2;168;0;255m')
      $(printf '\033[38;2;245;0;172m')
    "
        FMT_PURPLE=$(printf '\033[38;2;245;0;172m')
    else
        FMT_RAINBOW="
      $(printf '\033[38;5;196m')
      $(printf '\033[38;5;202m')
      $(printf '\033[38;5;226m')
      $(printf '\033[38;5;082m')
      $(printf '\033[38;5;021m')
      $(printf '\033[38;5;093m')
      $(printf '\033[38;5;163m')
    "
        FMT_PURPLE=$(printf '\033[38;5;163m')
    fi

    FMT_RED=$(printf '\033[31m')
    FMT_GREEN=$(printf '\033[32m')
    FMT_YELLOW=$(printf '\033[33m')
    FMT_BLUE=$(printf '\033[34m')
    FMT_BOLD=$(printf '\033[1m')
    FMT_RESET=$(printf '\033[0m')
}

get_linkable_files() {
    find -H "${DOTY}" -type f -name '*' -maxdepth $2
}

symlink_files_from() {
    # TODO: Add supports nested directory
    for source_file in $(get_linkable_files "${1}" 1) ; do
        file_name="$(basename "${source_file}")"
        target_file="${zdot}/${file_name}"

        if [ -f "$target_file" ] || [ -h "$target_file" ]; then
            mv "$target_file" "${backup_dir}/${file_name}"
        fi

        info "Creating symlink for $(fmt_code "${file}") to $(fmt_code "${target_file}")"
        # Force create/replace the symlink.
        ln -fs "${source_file}" "${target_file}"
    done
}

shellcheck_git_alias() {
    shellcheck --version

    info "Checking git aliases $(fmt_code "$1")..."

    git config --file="$1" --null --get-regexp '^alias\.' '^!' |
    while read -r -d $'\n' key
    do
        read -r -d $'\0' value
        info "    Checking $(fmt_code "${key:6}")..."  
        shellcheck --exclude SC2094,SC2119,SC2120 --shell=sh --color=always - <<< "${value:1}"
        success "    Successfully checked $(fmt_code "${key:6}")."
    done

    success "Successfully checked all aliases for $(fmt_code "$1")."
}

register_git_config() {
    shellcheck_git_alias "$2"

    if git config --global --get-all "$1" | grep -q "$2"; then
        warning "Git config $(fmt_code "$2") is already loaded"
    else
       git config --global --add "$1" "$2"
    fi
}

install_iterm2_colors() {
    filename="${1}"

    if [[ ! -f "$filename" ]]; then
        error "File not found: \"$filename\"."
        return 1
    elif ! (echo "$filename" | grep -qF '.itermcolors'); then
        error "Invalid iTerm color scheme file: \"$filename\"."
        return 1
    fi

    # Format the scheme name (capitalized)
    name="$(echo "$filename" |
        sed -E 's|.*/([^/]*)\.itermcolors|\1|g' |
        sed -E 's/([0-9a-zA-Z])_([0-9a-zA-Z])/\1 \2/g; s/([0-9a-zA-Z])-([0-9a-zA-Z])/\1 \2/g;'
    )"
    name=($name)
    name="${name[*]^}"
    name="$(echo "$name" | sed -E 's| In | in |g; s| Of | of |g; s| And | and |g; s| V([0-9]+)$| v\1|g')"

    # Create 'Custom Color Presets' entry if not exists
    if ! /usr/libexec/PlistBuddy -c 'Print "Custom Color Presets"' \
        "$HOME/Library/Preferences/com.googlecode.iterm2.plist" &>/dev/null; then
        info "Creating 'Custom Color Presets' entry ..."
        /usr/libexec/PlistBuddy -c 'Add \"Custom Color Presets\" dict' \
                    "$HOME/Library/Preferences/com.googlecode.iterm2.plist"
    fi

    # Import the color scheme
    info "Importing color scheme $name (\"$filename\") ..."
    if /usr/libexec/PlistBuddy -c "Print \"Custom Color Presets:$name\"" \
        "$HOME/Library/Preferences/com.googlecode.iterm2.plist" &>/dev/null; then
        # If already installed, delete first 
        /usr/libexec/PlistBuddy -c "Delete \"Custom Color Presets:$name\"" \
                    "$HOME/Library/Preferences/com.googlecode.iterm2.plist"
    fi

    # Install directly
    /usr/libexec/PlistBuddy \
            -c "Add \"Custom Color Presets:$name\" dict" \
            -c "Merge \"$filename\" \"Custom Color Presets:$name\"" \
            "$HOME/Library/Preferences/com.googlecode.iterm2.plist"
}

# Header logging
header() {
    text=${@}
    total_chars=${#text}

    if [ "$total_chars" -gt 80 ]; then
        total_chars=80
    fi

    printf "$(tput setaf 7)%s$(tput sgr0)\n" "$text" >&2
    for ((i = 1; i <= $total_chars; i++)); do
        printf "$(tput setaf 237)-$(tput sgr0)" >&2
    done
    printf '\n'  >&2
}

# shellcheck disable=SC2183  # printf string has more %s than arguments ($FMT_RAINBOW expands to multiple arguments)
print_header() {
    printf '%s       __%s\n' "${FMT_PURPLE}" "${FMT_RESET}" >&2
    printf '%s  ____/ /%s\n' "${FMT_PURPLE}" "${FMT_RESET}" >&2
    printf '%s / __  /%s\n' "${FMT_PURPLE}" "${FMT_RESET}" >&2
    printf '%s/ /_/ /%s\n' "${FMT_PURPLE}" "${FMT_RESET}" >&2
    printf '%s\\____/%s    %s.... %s%s\n' "${FMT_PURPLE}" "${FMT_BOLD}" "${FMT_GREEN}" "$*" "${FMT_RESET}" >&2
    printf '\n' >&2
    printf '\n' >&2
    printf '%s %s %s\n' \
        "Before you scream ${FMT_BOLD}${FMT_YELLOW}Doty!${FMT_RESET} look over the" \
        "$(codeblock "$(link ".zshrc" "file://$zdot/.zshrc" --text)")\n" \
        "file to select plugins, themes, and options." >&2
    printf '\n%s-------------------------------------------------------------------------------------------%s\n\n' "${FMT_BOLD}" "${FMT_RESET}" >&2
}

validate_requirements() {
    if ! command_exists zsh; then
        error "Zsh is not installed. Please install zsh first."
        exit 1
    fi

    if ! command_exists git; then
        error "git is not installed. Please install git first."
        exit 1
    fi

    # Before relying on Homebrew, check that packages can be compiled
    if ! command_exists 'gcc' && [[ "${OSTYPE}" == darwin* ]]; then
        error "The XCode Command Line Tools must be installed first."
        printf '\n' >&2
        printf 'Download them from: %s' "$(link "https://developer.apple.com/downloads")" >&2
        exit 2
    fi

    if [ -e "$backup_dir" ]; then
        error "Backup directory $(fmt_code "$backup_dir") already exists."
        error "Can't back up files re-run the installer again in a couple of seconds."
        exit 1
    fi

    if [ -d "$DOTY" ]; then
        warning "The $(fmt_code "\$DOTY")  folder already exists ($DOTY)."
        if [ "$custom_doty" = yes ]; then
            cat <<EOF

You run the installer with the $(fmt_code "\$DOTY") setting or the $(fmt_code "\$DOTY")  variable
is exported. You have 3 options:

1. Unset the DOTY variable when calling the installer:
   $(fmt_code "DOTY= sh install")
2. Install Doty to a directory that doesn't exist yet:
   $(fmt_code "DOTY=path/to/new/doty/folder sh install")
3. (Caution) If the folder doesn't contain important information,
   you can just remove it with $(fmt_code "rm -r $DOTY")

EOF
        else
            error "You'll need to remove it if you want to reinstall."
        fi

        exit 1
    fi
}

clone_doty() {
    # Prevent the cloned repository from having insecure permissions. Failing to do
    # so causes compinit() calls to fail with "command not found: compdef" errors
    # for users with insecure umasks (e.g., "002", allowing group writability). Note
    # that this will be ignored under Cygwin by default, as Windows ACLs take
    # precedence over umasks except for filesystems mounted with option "noacl".
    umask g-w,o-w

    header "Cloning Doty"

    ostype=$(uname)
    if [ -z "${ostype%CYGWIN*}" ] && git --version | grep -Eq 'msysgit|windows'; then
        error "Windows/MSYS Git is not supported on Cygwin"
        error "Make sure the Cygwin git package is installed and is first on the \$PATH"
        exit 1
    fi

    # Manual clone with git config options to support git < v1.7.2
    git init --quiet "$DOTY" && cd "$DOTY" &&
        git config core.eol lf &&
        git config core.autocrlf false &&
        git config fsck.zeroPaddedFilemode ignore &&
        git config fetch.fsck.zeroPaddedFilemode ignore &&
        git config receive.fsck.zeroPaddedFilemode ignore &&
        git config doty.remote origin &&
        git config doty.branch "$DOTY_REPOSITORY_BRANCH" &&
        git remote add origin "$DOTY_REPOSITORY_REMOTE" &&
        git fetch --depth=1 origin &&
        git checkout -b "$DOTY_REPOSITORY_BRANCH" "origin/$DOTY_REPOSITORY_BRANCH" || {
        [ ! -d "$DOTY" ] || {
            cd -
            rm -rf "$DOTY" 2>/dev/null
        }
        error "git clone $(fmt_code "$DOTY_REPOSITORY_REMOTE") repository failed"
        exit 1
    }

    git submodule update --init --recursive
	git submodule foreach 'git fetch origin; \
		git checkout $(git rev-parse --abbrev-ref HEAD); \
		git reset --hard origin/$(git rev-parse --abbrev-ref HEAD); \
		git submodule update --recursive --progress; \
		git clean -dfx'

    # Exit installation directory
    cd -

    info "Doty is cloned on $DOTY"
    printf '\n' >&2
}

setup_zshrc() {
    # Keep most recent old .zshrc at $backup_dir/.zshrc,
    # so we never actually destroy a user's original zshrc.
    header "Looking for an existing zsh config"

    # Must use this exact name so uninstall.sh can find it
    OLD_ZSHRC="$backup_dir/.zshrc"
    if [ -f "$zdot/.zshrc" ] || [ -h "$zdot/.zshrc" ]; then
        # Skip this if the user doesn't want to replace an existing .zshrc
        if [ "$KEEP_ZSHRC" = yes ]; then
            printf '%sFound %s.%s %sKeeping...%s\n' "${FMT_YELLOW}" "${zdot}/.zshrc" "${FMT_RESET}" "${FMT_GREEN}" "${FMT_RESET}" >&2
            return
        fi

        if [ -e "$OLD_ZSHRC" ]; then
            error "Backup .zshrc file $OLD_ZSHRC already exists."
            error "Can't back up ${zdot}/.zshrc re-run the installer again in a couple of seconds."
            exit 1
        fi

        warning "Found old $(fmt_code "${zdot}/.zshrc")."
        info "Backing up to $(fmt_code "${OLD_ZSHRC}")."
        cp "$zdot/.zshrc" "$OLD_ZSHRC"
    fi

    success "Using the Doty template file and adding it to $(fmt_code "$zdot/.zshrc")."

    if grep -q "^source .*\/doty" "$zdot/.zshrc"; then
        warning "$(fmt_code "${DOTY}/doty") is already sourced on your .zshrc"
    else
        # Source $DOTY/doty in .zshrc directory to use the literal $ZDOTDIR or $HOME
        echo "source \"${DOTY}/doty\"" >> "$zdot/.zshrc"
    fi
    printf '\n' >&2
}

setup_shell() {
    # Skip setup if the user wants or stdin is closed (not running interactively).
    if [ "$CHANGE_SHELL" = no ]; then
        return
    fi

    # If this user's login shell is already "zsh", do not attempt to switch.
    if [ "$(basename -- "$SHELL")" = "zsh" ]; then
        return
    fi

    header "Change default shell to zsh"

    # If this platform doesn't provide a "chsh" command, bail out.
    if ! command_exists chsh; then
        error "Doty can't change your shell automatically because this system does not have chsh."
        info "Please manually change your default shell to zsh!"
        return
    fi

    info "Time to change your default shell to zsh!"

    # Prompt for user choice on changing the default login shell
    printf '%sDo you want to change your default shell to zsh? [Y/n]%s ' "$FMT_YELLOW" "$FMT_RESET" >&2
    read -r opt
    case $opt in
    y* | Y* | "") ;;
    n* | N*)
        warning "Shell change skipped."
        return
        ;;
    *)
        error "Invalid choice. Shell change skipped."
        return
        ;;
    esac

    # Check if we're running on Termux
    case "$PREFIX" in
    *com.termux*)
        termux=true
        zsh=zsh
        ;;
    *) termux=false ;;
    esac

    if [ "$termux" != true ]; then
        # Test for the right location of the "shells" file
        if [ -f /etc/shells ]; then
            shells_file=/etc/shells
        elif [ -f /usr/share/defaults/etc/shells ]; then # Solus OS
            shells_file=/usr/share/defaults/etc/shells
        else
            error "Could not find $(fmt_code "/etc/shells") file."
            error "Please manually change your default shell!"
            return
        fi

        # Get the path to the right zsh binary
        # 1. Use the most preceding one based on $PATH, then check that it's in the shells file
        # 2. If that fails, get a zsh path from the shells file, then check it actually exists
        if ! zsh=$(command -v zsh) || ! grep -qx "$zsh" "$shells_file"; then
            if ! zsh=$(grep '^/.*/zsh$' "$shells_file" | tail -n 1) || [ ! -f "$zsh" ]; then
                error "No zsh binary found or not present in $(fmt_code "$shells_file")"
                error "Please manually change your default shell!"
                return
            fi
        fi
    fi

    # We're going to change the default shell, so back up the current one
    if [ -n "$SHELL" ]; then
        echo "$SHELL" > "$backup_dir/.shell"
    else
        grep "^$USER:" /etc/passwd | awk -F: '{print $7}' >"$backup_dir/.shell"
    fi

    info "Changing your shell to $(fmt_code "$zsh")..."

    info "Installing iterm2 color scheme..."
    install_iterm2_colors "${zdot}/config/solarized/iterm2-colors-solarized/Solarized Dark.itermcolors"
    install_iterm2_colors "${zdot}/config/solarized/iterm2-colors-solarized/Solarized Light.itermcolors"
    cp "${zdot}/config/solarized/apple-colorpalette-solarized/solarized.clr" "${HOME}/Library/Colors/"

    # Check if user has sudo privileges to run `chsh` with or without `sudo`
    #
    # This allows the call to succeed without password on systems where the
    # user does not have a password but does have sudo privileges, like in
    # Google Cloud Shell.
    #
    # On systems that don't have a user with passwordless sudo, the user will
    # be prompted for the password either way, so this shouldn't cause any issues.
    #
    if user_can_sudo; then
        sudo -k chsh -s "$zsh" "$USER" # -k forces the password prompt
    else
        chsh -s "$zsh" "$USER" # run chsh normally
    fi

    # Check if the shell change was successful
    if [ $? -ne 0 ]; then
        error "chsh command unsuccessful."
        error "Please manually change your default shell!"
    else
        export SHELL="$zsh"
        success "Shell successfully changed to $(fmt_code "$zsh")."
    fi

    printf '\n' >&2
}

setup_tmux() {
    # Keep most recent old .tmux.conf at $backup_dir/.tmux.conf,
    # so we never actually destroy a user's original .tmux.conf.
    header "Looking for an existing tmux config"

    # Must use this exact name so uninstall.sh can find it
    OLD_TMUX="$backup_dir/.tmux.conf"
    if [ -f "${zdot}/.tmux.conf" ] || [ -h "${zdot}/.tmux.conf" ]; then
        # Skip this if the user doesn't want to replace an existing .zshrc
        if [ "$KEEP_TMUXCONF" = yes ]; then
            printf '%sFound %s.%s %sKeeping...%s\n' "${FMT_YELLOW}" "${zdot}/.tmux.conf" "${FMT_RESET}" "${FMT_GREEN}" "${FMT_RESET}" >&2
            
            info "You need manually add doty tmux config to your existing tmux config file"
            printf '\n' >&2
            codeblock "    run \"\$DOTY_DIRECTORY/config/tmux/doty/doty\""
            printf '\n' >&2
            return
        fi

        if [ -e "$OLD_TMUX" ]; then
            error "Backup .tmux.conf file $OLD_TMUX already exists."
            error "Can't back up ${zdot}/.tmux.conf re-run the installer again in a couple of seconds."

            info "Or, you need manually add doty tmux config to your existing tmux config file"
            printf '\n' >&2
            codeblock "    run \"\$DOTY_DIRECTORY/config/tmux/doty/doty\""
            printf '\n' >&2
            exit 1
        fi

        warning "Found existing $(fmt_code "${zdot}/.tmux.conf")."
        info "Backing up to $(fmt_code "${OLD_TMUX}")."
        cp "$zdot/.tmux.conf" "$OLD_TMUX"
    fi

    success "Load Doty tmux configuration file and adding it to $(fmt_code "${zdot}/.tmux.conf")."

    if grep -q "^run .*\/config\/tmux\/doty\/doty" "${zdot}/.tmux.conf"; then
        warning "$(fmt_code "${DOTY}/config/tmux/doty/doty") is already sourced on your .tmux.conf"
    else
        echo "run '\$DOTY_DIRECTORY/config/tmux/doty/doty'" >> ${zdot}/.tmux.conf
    fi
    printf '\n' >&2
}

setup_nvim() {
    # Keep most recent old nvim/init.lua at $backup_dir/.config/nvim/init.lua,
    # so we never actually destroy a user's original nvim/init.lua.
    header "Looking for an existing nvim config"

    # Must use this exact name so uninstall.sh can find it
    OLD_NVIM="$backup_dir/.config/nvim/init.lua"
    if [ -f "${zdot}/.config/nvim/init.lua" ] || [ -h "${zdot}/.config/nvim/init.lua" ]; then
        # Skip this if the user doesn't want to replace an existing .zshrc
        if [ "$KEEP_NVIMCONF" = yes ]; then
            printf '%sFound %s.%s %sKeeping...%s\n' "${FMT_YELLOW}" "${zdot}/.config/nvim/init.lua" "${FMT_RESET}" "${FMT_GREEN}" "${FMT_RESET}" >&2

            info "You need manually load doty nvim plugin to your existing nvim config file"
            printf '\n' >&2
            codeblock "    vim.opt.rtp:prepend(os.getenv(\"DOTY_DIRECTORY\") .. \"/config/nvim/after\")"
            codeblock "    vim.opt.rtp:prepend(os.getenv(\"DOTY_DIRECTORY\") .. \"/config/nvim\")"
            codeblock "    require(\"doty\")"
            printf '\n' >&2
            return
        fi

        if [ -e "$OLD_NVIM" ]; then
            error "Backup nvim file $OLD_NVIM already exists."
            error "Can't back up ${zdot}/.config/nvim/init.lua re-run the installer again in a couple of seconds."

            info "Or, you need manually load doty nvim plugin to your existing nvim config file"
            printf '\n' >&2
            codeblock "    vim.opt.rtp:prepend(os.getenv(\"DOTY_DIRECTORY\") .. \"/config/nvim/after\")"
            codeblock "    vim.opt.rtp:prepend(os.getenv(\"DOTY_DIRECTORY\") .. \"/config/nvim\")"
            codeblock "    require(\"doty\")"
            printf '\n' >&2
            exit 1
        fi

        warning "Found existing $(fmt_code "${zdot}/.config/nvim/init.lua")."
        info "Backing up to $(fmt_code "${OLD_NVIM}")."
        cp "${zdot}/.config/nvim/init.lua" "$OLD_NVIM"
    fi

    success "Load Doty nvim plugin file and adding it to $(fmt_code "${zdot}/.config/nvim/init.lua")."

    if grep -q "^require.*\"doty\"" "${zdot}/.config/nvim/init.lua"; then
        warning "Doty nvim plugin is already loaded on your .config/nvim/init.lua"
    else
        cat <<EOT >>${zdot}/.config/nvim/init.lua
vim.opt.rtp:prepend(os.getenv("DOTY_DIRECTORY") .. "/config/nvim/after")
vim.opt.rtp:prepend(os.getenv("DOTY_DIRECTORY") .. "/config/nvim")

require("doty")
EOT
    fi
    printf '\n' >&2
}

setup_git() {
    #  Set git global options and install commons tools
    header "Configure global git options"

    info "Load git config"
    
    register_git_config include.path "${DOTY}/libraries/gitalias/gitalias.txt"

    register_git_config include.path "${DOTY}/config/git/.gitconfig"
    register_git_config core.excludesfile "${DOTY}/config/git/gitignore"
    register_git_config core.attributesfile "${DOTY}/config/git/gitattributes"

    info "Install git integration tools..."
    # Git integration
    integration_dir=$(mktemp -d)
    git clone https://github.com/johnkeeping/git-integration ${integration_dir}
    cd ${integration_dir}
    echo "${HOME}/.local" > config.mak
    make install
    make install-doc
    make install-completion

    # Exit installation directory
    cd -

    success "Git configured!"
    printf '\n' >&2
}

setup_symlink() {
    # Create the necessary symbolic links between the `.dotfiles` and `HOME`
    # directory. The `bash_profile` sources other files directly from the
    # `.dotfiles` repository.
    header "Mirroring config files"
    
    symlink_files_from "config/symlink"

    success "Symlink dotfiles complete!"
    printf '\n' >&2
}

install() {
    # Create backup_dir folder structure if it doesn't exist
    if [ -n "$backup_dir" ]; then
        mkdir -p "$backup_dir"
    fi

    # Create ZDOTDIR folder structure if it doesn't exist
    if [ -n "$ZDOTDIR" ]; then
        mkdir -p "$ZDOTDIR"
    fi

    print_header "is now installing"
    
    clone_doty
    setup_zshrc
    setup_shell
    setup_tmux
    setup_nvim
    setup_git
    setup_symlink

    success "Doty is now installed!"

    if [ $RUN_ZSH = no ]; then
        warning "Run zsh to try it out."
        printf '\n\n' >&2
        exit
    fi

    printf '\n\n' >&2
    exec zsh -l
}

main() {
    # Run as unattended if stdin is not a tty
    if [ ! -t 0 ]; then
        RUN_ZSH=no
        CHANGE_SHELL=no
    fi

    # Parse arguments
    while [ $# -gt 0 ]; do
        case $1 in
        --unattended)
            RUN_ZSH=no
            CHANGE_SHELL=no
            shift
            ;;
        --no-change-shell)
            CHANGE_SHELL=no
            shift
            ;;
        --keep-zshrc)
            KEEP_ZSHRC=yes
            shift
            ;;
        --keep-tmux)
            KEEP_TMUXCONF=yes
            shift
            ;;
        --keep-nvim)
            KEEP_NVIMCONF=yes
            shift
            ;;
        esac
    done

    setup_color
    validate_requirements
    install
}

main "$@"
